# ch_12_2_python_multiprocess

### 프로세스란?

디스크에 저장되어 있는 코드가 메모리를 할당받아 로드되면 프로세스가 됩니다. python 명령어로 파이썬 파일을 하나 실행하면, 프로세스를 하나 만들게 됩니다.

```python
import math
import time

NUMS = [
    112272535095293, 112582705942171, 112272535095293, 115280095190773, 115797848077099,
    1099726899285419, 928565482900633, 620949300806017, 920242272907829, 847215622718557,
    170327999436563, 832533395805983, 679961235426119, 109798127748797, 873507126661997,
    255865904683583, 733050839039087, 454673305780171, 350022585241123, 812129226047863,
    352731124627649, 803273305316329, 623273913665089, 183268443527171, 723689261197363,
    128267158049687, 510406862720527, 309864269670691, 201370611411253, 663231003326791,
    989370579349183, 367611961123681, 907372112551027, 519229612165057, 918441359020403,
    307318914657121, 815924138602981, 851898781094261, 710269849936327, 625955170587641,
    547255190548007, 385382988754873, 461312676728833, 463484715563027, 353946983238809,
    726383487363283, 233012756502683, 307908192029077, 250138324607461, 548890602505801,
]

def is_prime(n):
    if n < 2:
        return False
    if n == 2:
        return True
    if n % 2 == 0:
        return False

    sqrt_n = int(math.floor(math.sqrt(n)))
    for i in range(3, sqrt_n + 1, 2):
        if n % i == 0:
            return False
    return True

if __name__ == '__main__':
    start = time.time()
    for num in NUMS:
        prime = is_prime(num)
        print(f'{num} is prime: {prime}')
    print("elapsed", time.time() - start)
```

![Untitled](ch_12_2_python_multiprocess%2038960970f74c42d8b431c4564494daa9/Untitled.png)

![Untitled](ch_12_2_python_multiprocess%2038960970f74c42d8b431c4564494daa9/Untitled%201.png)

1부터 1억까지 수를 제곱하는 간단한 함수입니다만, 완료하는데 20초가 넘게 걸렸습니다.

### python GIL

python은 내부적으로 global interpreter lock이라는 장치가 있습니다. 이는 하나의 python process가 실질적으론 하나의 CPU core를 사용할 수 밖에 없도록 제한합니다. 

![Untitled](ch_12_2_python_multiprocess%2038960970f74c42d8b431c4564494daa9/Untitled%202.png)

### python multicore programming

그렇다면 GIL의 영향에서 벗어나 멀티코어를 사용하고 싶다면 어떻게 할 수 있을까요? 바로 python multiprocess를 사용하는 것입니다. python process pool executor를 사용하면 손쉽게 멀티 프로세스를 사용할 수 있습니다.

```python
import math
import time

from concurrent.futures import ProcessPoolExecutor

NUMS = [
    112272535095293, 112582705942171, 112272535095293, 115280095190773, 115797848077099,
    1099726899285419, 928565482900633, 620949300806017, 920242272907829, 847215622718557,
    170327999436563, 832533395805983, 679961235426119, 109798127748797, 873507126661997,
    255865904683583, 733050839039087, 454673305780171, 350022585241123, 812129226047863,
    352731124627649, 803273305316329, 623273913665089, 183268443527171, 723689261197363,
    128267158049687, 510406862720527, 309864269670691, 201370611411253, 663231003326791,
    989370579349183, 367611961123681, 907372112551027, 519229612165057, 918441359020403,
    307318914657121, 815924138602981, 851898781094261, 710269849936327, 625955170587641,
    547255190548007, 385382988754873, 461312676728833, 463484715563027, 353946983238809,
    726383487363283, 233012756502683, 307908192029077, 250138324607461, 548890602505801,
]

def is_prime(n):
    if n < 2:
        return False
    if n == 2:
        return True
    if n % 2 == 0:
        return False

    sqrt_n = int(math.floor(math.sqrt(n)))
    for i in range(3, sqrt_n + 1, 2):
        if n % i == 0:
            return False
    return True

if __name__ == '__main__':
    start = time.time()
    with ProcessPoolExecutor(max_workers=10) as executor:
        results = executor.map(is_prime, NUMS)
        for num, result in zip(NUMS, results):
            print(f"{num} is prime: {result}")
    print(f"elapsed: {time.time() - start}")
```

![Untitled](ch_12_2_python_multiprocess%2038960970f74c42d8b431c4564494daa9/Untitled%203.png)

![Untitled](ch_12_2_python_multiprocess%2038960970f74c42d8b431c4564494daa9/Untitled%204.png)

ProcessPoolExecutor를 생성할 때, 사용하고자 하는 프로세스의 개수를 max_workers 파라미터에 전달하면, 해당 개수만큼 멀티 프로세스를 만들어서 작업을 수행합니다. 작업을 수행하고자 하는 함수를 먼저 만들고, 여기에 반복을 돌 수 있는 데이터를 매핑하면, 미리 만들어져 있는 프로세스들에 데이터가 나누어져 연산을 수행한 다음, 결과를 리턴하게 됩니다. 즉, 멀티 코어를 사용하여 빠르게 연산을 수행하게 됩니다.

## 정리

이번 챕터에서는 프로세스의 기본 개념과 python ProcessPoolExecutor를 이용한 multiprocess programming에 대해서 배워보았습니다. 기본적으로 단일 python process는 GIL 떄문에 CPU 코어를 하나밖에 사용할 수 없지만, 프로세스 자체를 여러개로 늘리는 방법을 사용하여 멀티 코어를 이용할 수 있었습니다. 다음 챕터에서는 실제로 멀티 프로세스를 이용하여 토큰화를 빠르게 수행하는 실습을 해보겠습니다.